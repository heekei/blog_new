<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Docker 总结：《Docker 从入门到实战(黄靖钧)》 | Lorain&#39;s个人主页</title>
    <meta name="description" content="记录技术&amp;生活">
    <link rel="icon" href="/blog/hd-img.jpg">
  <link rel="manifest" href="/blog/hd-img.jpg">
  <link rel="apple-touch-icon" href="/blog/hd-img.jpg">
  <meta http-quiv="pragma" cotent="no-cache">
  <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
  <meta http-quiv="expires" cotent="0">
    
    <link rel="preload" href="/blog/assets/css/0.styles.44620038.css" as="style"><link rel="preload" href="/blog/assets/js/app.679a839d.js" as="script"><link rel="preload" href="/blog/assets/js/2.a9010d75.js" as="script"><link rel="preload" href="/blog/assets/js/13.268651e9.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.85571b53.js"><link rel="prefetch" href="/blog/assets/js/11.a1503d52.js"><link rel="prefetch" href="/blog/assets/js/12.a15bbf12.js"><link rel="prefetch" href="/blog/assets/js/14.dbfaca25.js"><link rel="prefetch" href="/blog/assets/js/15.1a28083a.js"><link rel="prefetch" href="/blog/assets/js/16.e024df52.js"><link rel="prefetch" href="/blog/assets/js/17.97827804.js"><link rel="prefetch" href="/blog/assets/js/18.a18598ac.js"><link rel="prefetch" href="/blog/assets/js/19.111e5556.js"><link rel="prefetch" href="/blog/assets/js/20.5b6bf982.js"><link rel="prefetch" href="/blog/assets/js/21.bebc1bc9.js"><link rel="prefetch" href="/blog/assets/js/3.cc0c8006.js"><link rel="prefetch" href="/blog/assets/js/4.31208fab.js"><link rel="prefetch" href="/blog/assets/js/5.5c87b6d9.js"><link rel="prefetch" href="/blog/assets/js/6.fc40567b.js"><link rel="prefetch" href="/blog/assets/js/7.3147bfb7.js"><link rel="prefetch" href="/blog/assets/js/8.21439bc3.js"><link rel="prefetch" href="/blog/assets/js/9.0a3555a4.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.44620038.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">Lorain's个人主页</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/skills/" class="nav-link router-link-active">记录技术</a></div><div class="nav-item"><a href="/blog/algorithm/" class="nav-link">算法相关</a></div><div class="nav-item"><a href="/blog/life/" class="nav-link">热爱生活</a></div><div class="nav-item"><a href="https://github.com/lorainwings" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/skills/" class="nav-link router-link-active">记录技术</a></div><div class="nav-item"><a href="/blog/algorithm/" class="nav-link">算法相关</a></div><div class="nav-item"><a href="/blog/life/" class="nav-link">热爱生活</a></div><div class="nav-item"><a href="https://github.com/lorainwings" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>技术进阶</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Html5</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Linux相关</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/skills/docker.html" class="active sidebar-link">Docker 总结：《Docker 从入门到实战(黄靖钧)》</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/skills/docker.html#常用命令表" class="sidebar-link">常用命令表</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="docker-总结：《docker-从入门到实战-黄靖钧-》"><a href="#docker-总结：《docker-从入门到实战-黄靖钧-》" class="header-anchor">#</a> Docker 总结：《Docker 从入门到实战(黄靖钧)》</h1> <h1 id="观其大纲"><a href="#观其大纲" class="header-anchor">#</a> 观其大纲</h1> <p>第一篇 容器技术与 Docker 概念<br>
1 认识容器技术<br>
2 Docker 基本概念<br>
3 安装和测试 Docker<br>
第二篇 Docker 基础知识<br>
4 Docker 基础<br>
5 Docker 镜像<br>
6 Dockerfile 文件<br>
7 Docker 仓库<br>
8 Docker 容器<br>
9 数据卷<br>
10 网络管理<br>
第三篇 Docker 进阶实战<br>
11 操作系统<br>
12 编排工具-compose<br>
13 web 服务器与应用<br>
14 数据库<br>
15 编程语言<br>
16 Docker API<br>
17 私有仓库<br>
18 集群网络<br>
19 容器安全<br>
20 Docker 网络生态</p> <h1 id="大纲细节"><a href="#大纲细节" class="header-anchor">#</a> 大纲细节</h1> <p>第 1 篇 容器技术与 Docker 概念<br>
第 1 章 容器技术<br>
1.1 什么是容器<br>
1.2 容器技术的前世今生<br>
1.3 容器的原理<br>
1.4 容器云<br>
1.5 容器与 Docker<br>
1.6 本章小结<br>
第 2 章 Docker 简介<br>
2.1 什么是 Docker<br>
2.2 Docker 的功能及优缺点<br>
2.3 Docker 和虚拟机<br>
2.4 Docker 与 runC<br>
2.5 Docker 基本架构<br>
2.6 本章小结<br>
第 3 章 安装 Docker<br>
3.1 Linux 系统<br>
3.2 Windows 与 Mac OS 系统<br>
3.3 二进制安装<br>
3.4 本章小结<br>
第 2 篇 Docker 基础知识<br>
第 4 章 Docker 基础<br>
4.1 Docker 基本操作<br>
4.2 启动第一个 Docker 容器<br>
4.3 构建第一个 Docker 镜像<br>
4.4 本章小结<br>
第 5 章 Docker 镜像<br>
5.1 认识镜像<br>
5.2 创建镜像<br>
5.3 导出和导入镜像<br>
5.4 发布镜像<br>
5.5 删除镜像<br>
5.6 Docker 镜像扩展<br>
5.7 本章小结<br>
第 6 章 Dockerfile 文件<br>
6.1 Dockerfile 基本结构<br>
6.2 Dockerfile 指令<br>
6.3 镜像构建实战<br>
6.4 本章小结<br>
第 7 章 Docker 仓库<br>
7.1 官方仓库 Docker Hub<br>
7.2 国内镜像仓库<br>
7.3 私有仓库<br>
7.4 Registry 原理<br>
7.5 本章小结<br>
第 8 章 Docker 容器<br>
8.1 容器基本操作<br>
8.2 进入容器内部<br>
8.3 导出和导入容器<br>
8.4 容器结构<br>
8.5 本章小结<br>
第 9 章 数据卷<br>
9.1 数据卷是什么<br>
9.2 为容器挂载数据卷<br>
9.3 备份、恢复、迁移数据卷<br>
9.4 容器数据卷扩展<br>
9.5 本章小结<br>
第 10 章 网络管理<br>
10.1 Docker 网络基础<br>
10.2 Docker 网络模式<br>
10.3 Docker 网络配置<br>
10.4 本章小结<br>
第 3 篇 Docker 进阶实战<br>
第 11 章 操作系统<br>
11.1 Alpine 发行版<br>
11.2 Busybox 发行版<br>
11.3 Debian/Ubuntu 发行版<br>
11.4 CentOS/Fedora 发行版<br>
11.5 CoreOS 发行版<br>
11.6 RancherOS 发行版<br>
11.7 本章小结<br>
第 12 章 编排工具 Compose<br>
12.1 安装 Docker Compose<br>
12.2 Compose 命令基础<br>
12.3 Compose 配置文件<br>
12.4 Compose 实战<br>
12.5 本章小结<br>
第 13 章 Web 服务器与应用<br>
13.1 Apache 服务器<br>
13.2 Nginx 服务器<br>
13.3 Tomcat 服务器<br>
13.4 其他 Web 服务器<br>
13.5 本章小结<br>
第 14 章 数据库<br>
14.1 MySQL 数据库<br>
14.2 PostgreSQL 数据库<br>
14.3 Redis 数据库<br>
14.4 MongoDB 数据库<br>
14.5 其他<br>
14.6 本章小结<br>
第 15 章 编程语言<br>
15.1 C/C++语言<br>
15.2 Golang 语言<br>
15.3 Java 语言<br>
15.4 JavaScript（Node.js）语言<br>
15.5 PHP 语言<br>
15.6 Python 语言<br>
15.7 Swift 语言<br>
15.8 本章小结<br>
第 16 章 Docker API 介绍<br>
16.1 认识 Docker API<br>
16.2 Docker Remote API 介绍<br>
16.3 其他 API<br>
16.4 本章小结<br>
第 17 章 私有仓库<br>
17.1 Docker Registry 介绍<br>
17.2 认证与前端<br>
17.3 企业级私有仓库 Harbor<br>
17.4 私有仓库前端授权工具 Portus<br>
17.5 本章小结<br>
第 18 章 集群网络<br>
第 19 章 Docker 安全</p> <hr> <h1 id="熟知概念"><a href="#熟知概念" class="header-anchor">#</a> 熟知概念</h1> <p>第 1 篇 容器技术与 Docker 概念<br>
第 1 章 容器技术</p> <blockquote><ul><li><p>什么是容器<br>
容器映像是一个软件的轻量级独立可执行软件包，包含运行它所需的一切：代码，运行时，系统工具，系统库，设置。不管环境如何，集装箱化软件都可以运行相同的 Linux 和 Windows 应用程序。容器将软件与其周围环境隔离开来，例如开发环境和登台环境之间的差异，并有助于减少在同一基础架构上运行不同软件的团队之间的冲突。</p> <p><img src="invalid-url.png" alt=""></p> <p>what is a container?</p></li></ul></blockquote> <blockquote><p>LXC<br>
Linux Container 容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源。</p></blockquote> <blockquote><p>容器技术主要包括 Cgroup 和 Namespace 这两个内核特性。<br> <strong>Cgroup</strong><br>
Cgroup 是 control group，又称为控制组，它主要是做资源控制。原理是将一组进程放在放在一个控制组里，通过给这个控制组分配指定的可用资源，达到控制这一组进程可用资源的目的。<br> <strong>Namespace</strong><br>
Namespace 又称为命名空间，它主要做访问隔离。其原理是针对一类资源进行抽象，并将其封装在一起提供给一个容器使用，对于这类资源，因为每个容器都有自己的抽象，而他们彼此之间是不可见的，所以就可以做到访问隔离。</p></blockquote> <blockquote><p>对于 Linux 容器的最小组成，除了上面两个抽象的技术概念还不够，完整的容器可以用以下公示描述：</p></blockquote> <h4 id="容器-cgroup-namespace-rootfs-容器引擎（用户态工具）。"><a href="#容器-cgroup-namespace-rootfs-容器引擎（用户态工具）。" class="header-anchor">#</a> 容器=Cgroup+Namespace+rootfs+容器引擎（用户态工具）。</h4> <blockquote><p>其中各项功能分别为：<br>
Cgroup：资源控制；<br>
Namespace：访问隔离；<br>
rootfs：文件系统隔离；<br>
容器引擎：生命周期控制；</p></blockquote> <p>第 2 章 Docker 简介<br>
2.1 什么是 Docker</p> <blockquote><p>Docker 是一个用于开发、迁移、运行的开发平台。它使你能够将你的应用程序从基础架构中分离，从而可以快速交付。使用 Docker，你可以以与管理应用程序相同的方式来管理这些基础架构。使用 Docker 的方法，进行快速开发，测试，并可以显著的减少编写代码和运行之间的时间延迟。<br>
就像官网上说的：Build，Ship，and Run Any App, Anywhere</p></blockquote> <blockquote><p>Docker 基本架构<br>
docker 主要有以下几部分组成：</p> <blockquote><p>Docker Client 客户端<br>
Docker daemon 守护进程<br>
Docker Image 镜像<br>
Docker Container 容器<br>
Docker Registry 仓库</p></blockquote></blockquote> <blockquote><ul><li><p>客户端和守护进程：<br>
1 Docker 是 C/S（客户端 client-服务器 server）架构模式。<br>
docker 通过客户端连接守护进程，通过命令向守护进程发出请求，守护进程通过一系列的操作返回结果。<br>
2 docker 客户端可以连接本地或者远程的守护进程。<br>
3 docker 客户端和服务器通过 socket 或 RESTful API 进行通信。</p> <p><img src="invalid-url.png" alt=""></p> <p>docker 架构</p></li></ul></blockquote> <p>第 3 章 安装 Docker</p> <p>第 2 篇 Docker 基础知识<br>
第 4 章 Docker 基础</p> <h2 id="常用命令表"><a href="#常用命令表" class="header-anchor">#</a> 常用命令表</h2> <blockquote><ul><li>操作 命令<br>
实例</li></ul></blockquote> <h4 id="通用命令"><a href="#通用命令" class="header-anchor">#</a> 通用命令</h4> <ul><li>查看 docker 版本 docker version<br>
docker version</li> <li>查看 docker 信息 docker info<br>
docker info</li> <li>查看某命令 help 信息 docker help [command]<br>
docker help attach</li> <li>查看 docker help 信息 docker --help<br>
docker --help</li></ul> <h4 id="容器操作命令"><a href="#容器操作命令" class="header-anchor">#</a> 容器操作命令</h4> <ul><li>创建 container docker create<br>
docker create chenhengjie123/xwalkdriver</li> <li>创建并运行 container docker run<br>
docker run chenhengjie123/xwalkdriver /bin/bash</li> <li>创建并运行 container 后进入其 bash 控制台<br>
docker run -t -i image /bin/bash<br>
docker run -t -i ubuntu /bin/bash</li> <li>创建并运行 container 并让其在后台运行，并端口映射<br>
docker run -p [port in container]:[port in physical system] -d [image] [command]<br>
docker run -p 5000:5000 -d training/webapp python app.py</li> <li>查看正在运行的所有 container 信息 docker ps<br>
docker ps</li> <li>查看最后创建的 container docker ps -l<br>
docker ps -l</li> <li>查看所有 container ，包括正在运行和已经关闭的 docker ps -a<br>
docker ps -a</li> <li>输出指定 container 的 stdout 信息（用来看 log ，效果和 tail -f 类似，会实时输出。）<br>
docker logs -f [container]<br>
docker logs -f nostalgic_morse<br> <strong>补充 docker logs -f -t --since=&quot;2017-05-01&quot; --tail=10 edu_web_01</strong></li> <li>获取 container 指定端口映射关系 docker port [container] [port]<br>
docker port nostalgic_morse 5000</li> <li>查看 container 进程列表 docker top [container]<br>
docker top nostalgic_morse</li> <li>查看 container 详细信息 docker inspect [container]<br>
docker inspect nostalgic_morse</li> <li>停止 continer docker stop [container]<br>
docker stop nostalgic_morse</li> <li>强制停止 container docker kill [container]<br>
docker kill nostalgic_morse</li> <li>启动一个已经停止的 container docker start [container]<br>
docker start nostalgic_morse</li> <li>重启 container (若 container 处于关闭状态，则直接启动)<br>
docker restart [container]<br>
docker restart nostalgic_morse</li> <li>删除 container docker rm [container]<br>
docker rm nostalgic_morse</li></ul> <p>注意：命令中需要指定 container 时，既可使用其名称，也可使用其 id 。</p> <h4 id="镜像操作命令"><a href="#镜像操作命令" class="header-anchor">#</a> 镜像操作命令</h4> <ul><li>从 container 创建 image， docker commit [container] [imageName]<br>
docker commit nostalgic_morse ouruser/sinatra:v2</li> <li>从 Dockerfile 创建 image， docker build -t [imageName] [pathToFolder]<br>
docker build ouruser/sinatra:v3 .</li> <li>查看本地所有 image， docker images<br>
docker images</li> <li>显示镜像构建历史 docker history [OPTIONS] IMAGE<br>
docker history runoob/ubuntu:v3</li> <li>在 registry 中搜索镜像 docker search [query]<br>
docker search ubuntu</li> <li>从 registry 中获取镜像 （若无指定 tag 名称，则默认使用 latest 这个 tag）<br>
docker pull [imageName]<br>
docker pull ubuntu:14.04<br>
docker pull training/webapp</li> <li>给 image 打 tag， docker tag [imageId] [imageName]<br>
docker tag 5db5f8471261 ouruser/sinatra:devel</li> <li>把本地 image 上传到 registry 中 (此时会把所有 tag 都上传上去)<br>
docker push [imageName]<br>
docker push ouruser/sinatra</li> <li>删除本地 image， docker rmi [image]<br>
docker rmi training/sinatra</li></ul> <p>注意：注意：image 中没有指定 tag 名称的话默认使用 latest 这个 tag 。然而 latest 的含义和 VCS 中的 head 不一样，不是代表最新一个镜像，仅仅是代表 tag 名称为 latest 的镜像。若不存在 tag 名称为 latest 的镜像则会报错。</p> <p>小结：</p> <blockquote><p>docker 虽然是一个虚拟化技术，但使用上却更像是在管理系统软件或者代码。里面的一些 ps，top，rm 命令让使用 Linux 命令的人感到十分亲切（虽然它们的语义有点不一样。。。），start，stop，restart 让你感觉像是在控制 service ，而 push，pull，commit，tag 又让你觉得像是在使用 git 。因此程序员会感到很亲切且容易上手。</p></blockquote> <blockquote><p>同时由于可以使用 Dockerfile 进行 image 的构建，且 docker hub 支持从 github 等地方自动根据 Dockerfile 进行构建，所以 docker 把运行环境也集成到 CI 中了。</p></blockquote> <blockquote><p>美中不足的是由于 docker 目前仅支持 linux 上的容器技术，因此它要在非 Linux 系统下运行必须加多一个虚拟机层。这会造成一些在 Linux 上运行不会出现的问题（ip 地址、硬件资源、文件映射等），同时由于基于 linux ，一些 windows 的程序会水土不服，泛用性比虚拟机差一些。</p></blockquote> <blockquote><p>但带来的好处是占用的系统资源低很多。一个只能开数个虚拟机的电脑一般能开数十个 container ，且 container 的启动时间一般在数秒内，比虚拟机快得多。另外，由于 docker 的 image 除了一些特殊的基础镜像外基本都是增量镜像，因此重复部分不会耗费额外的资源，所以几个看起来有数 g 的 image 如果里面使用的基础镜像有重复部分（大部分情况下都会有部分重复），那么它们实际占用空间将会小得多。</p></blockquote> <p>第 5 章 Docker 镜像<br>
5.1 认识镜像<br>
镜像是 Docker 容器的基石，容器是镜像的运行实例，有了镜像才能启动容器。</p> <h5 id="docker-镜像中的-base-镜像理解"><a href="#docker-镜像中的-base-镜像理解" class="header-anchor">#</a> Docker 镜像中的 base 镜像理解</h5> <ul><li><p>base 镜像有两层含义：<br>
1 不依赖其他镜像，从 scratch 构建。<br>
2 其他镜像可以之为基础进行扩展。<br>
能称作 base 镜像的通常都是各种 Linux 发行版的 Docker 镜像，比如 Ubuntu, Debian, CentOS 等</p></li> <li><p>base 镜像内容：<br>
下载镜像：<br>
docker pull centos<br>
查看镜像信息：docker images centos # 大约 200M<br>
Linux 操作系统由内核空间和用户空间组成。如下图所示：</p></li></ul> <p><img src="invalid-url.png" alt=""></p> <p>linux 操作系统</p> <p>rootfs</p> <ul><li>内核空间是 kernel，Linux 刚启动时会加载 bootfs 文件系统，之后 bootfs 会被卸载掉。</li> <li>用户空间的文件系统是 rootfs，包含我们熟悉的 /dev, /proc, /bin 等目录。对于 base 镜像来说，底层直接用 Host 的 kernel，自己只需要提供 rootfs 就行了。</li> <li>而对于一个精简的 OS，rootfs 可以很小，只需要包括最基本的命令、工具和程序库就可以了。相比其他 Linux 发行版，CentOS 的 rootfs 已经算臃肿的了，alpine 还不到 10MB。</li> <li>我们平时安装的 CentOS 除了 rootfs 还会选装很多软件、服务、图形桌面等，需要好几个 GB 就不足为奇了。</li> <li>base 镜像提供的是最小安装的 Linux 发行版。</li></ul> <blockquote><p>base 镜像----提供了一个基本的操作系统环境，用户可以根据需要安装和配置软件<br>
base 镜像通常是各种 Linux 发行版的 Docker 镜像比如 ubuntu、Debian、centos 等。<br>
**base 镜像只是在用户空间与发行版一致，kernel 版本与发行版是不同的。**比如说虚机系统是 ubuntu14.04，运行一个容器是 centos 系统的，那么 centos 使用的其实就是本虚机的 kernel。</p></blockquote> <p>5.2 创建镜像</p> <blockquote><p>当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。</p> <ul><li>列出镜像列表<br>
我们可以使用 docker images 来列出本地主机上的镜像。<br>
我们如果要使用版本为 15.10 的 ubuntu 系统镜像来运行容器时，命令如下：<br>
docker run -t -i ubuntu:15.10 /bin/bash</li> <li>获取一个新的镜像<br>
当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。<br>
docker pull ubuntu:13.10</li> <li>查找镜像<br>
我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： <a href="https://hub.docker.com/" target="_blank" rel="noopener noreferrer">https://hub.docker.com/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><br>
我们也可以使用 docker search 命令来搜索镜像。比如我们需要一个 httpd 的镜像来作为我们的 web 服务。我们可以通过 docker search 命令搜索 httpd 来寻找适合我们的镜像。<br>
docker search httpd</li> <li>创建镜像<br>
当我们从 docker 镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改。<br>
1.从已经创建的容器中更新镜像，并且提交这个镜像<br>
2.使用 Dockerfile 指令来创建一个新的镜像</li></ul></blockquote> <blockquote><ul><li>更新镜像<br>
更新镜像之前，我们需要使用镜像来创建一个容器。<br>
docker run -t -i ubuntu:15.10 /bin/bash<br>
在运行的容器内使用命令进行更新:<br>
apt-get update<br>
在完成操作之后，输入 exit 命令来退出这个容器。<br>
此时 ID 为 e218edb10161 的容器，是按我们的需求更改的容器。我们可以通过命令 docker commit 来提交容器副本。<br>
docker commit -m=&quot;has update&quot; -a=&quot;runoob&quot; e218edb10161 runoob/ubuntu:v2</li></ul> <blockquote><p>各个参数说明：<br>
-m:提交的描述信息<br>
-a:指定镜像作者<br>
e218edb10161：容器 ID<br>
runoob/ubuntu:v2:指定要创建的目标镜像名</p></blockquote> <ul><li>构建镜像<br>
我们使用命令 docker build ， 从零开始来创建一个新的镜像。为此，我们需要创建一个 Dockerfile 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。</li></ul></blockquote> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>runoob@runoob:~$ <span class="token function">cat</span> Dockerfile 
FROM    centos:6.7
MAINTAINER      Fisher <span class="token string">&quot;fisher@sudops.com&quot;</span>

RUN     /bin/echo <span class="token string">'root:123456'</span> <span class="token operator">|</span>chpasswd
RUN     <span class="token function">useradd</span> runoob
RUN     /bin/echo <span class="token string">'runoob:123456'</span> <span class="token operator">|</span>chpasswd
RUN     /bin/echo -e <span class="token string">&quot;LANG=<span class="token entity" title="\&quot;">\&quot;</span>en_US.UTF-8<span class="token entity" title="\&quot;">\&quot;</span>&quot;</span> <span class="token operator">&gt;</span>/etc/default/local
EXPOSE  <span class="token number">22</span>
EXPOSE  <span class="token number">80</span>
CMD     /usr/sbin/sshd -D
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><blockquote><p>每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。<br>
FROM，指定使用哪个镜像源<br>
RUN 指令告诉 docker 在镜像内执行命令，安装了什么。<br>
然后，我们使用 Dockerfile 文件，通过 docker build 命令来构建一个镜像。</p></blockquote> <h4 id="docker-build-t-runoob-centos-6-7"><a href="#docker-build-t-runoob-centos-6-7" class="header-anchor">#</a> docker build -t runoob/centos:6.7 .</h4> <blockquote><p>-t 指定要创建的目标镜像名<br>
. Dockerfile 文件所在目录，可以指定 Dockerfile 的绝对路径<br>
使用 docker images 查看创建的镜像</p></blockquote> <blockquote><ul><li>设置镜像标签<br>
我们可以使用 docker tag 命令，为镜像添加一个新的标签。<br>
docker tag 860c279d2fec runoob/centos:dev</li></ul></blockquote> <p>5.3 导出和导入镜像</p> <ul><li>将镜像导出到文件<br>
docker export cbe3cb7799ed &gt; update.tar</li> <li>基于导出的文件创建一个新静像（导入镜像）<br>
docker import - update &lt; update.tar<br>
新镜像为 update</li> <li>镜像的备份和恢复 save 和 load<br>
docker save -o update1.tar update<br>
备份， -o 输出到文件<br>
docker rmi update<br>
docker load &lt; update1.tar<br>
恢复</li></ul> <p>5.4 发布镜像<br>
5.5 删除镜像<br>
5.6 Docker 镜像扩展</p> <p>第 6 章 Dockerfile 文件<br>
6.1 Dockerfile 基本结构<br>
DockerFile 分为四部分组成：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。例如：</p> <div class="language-ruby line-numbers-mode"><pre class="language-ruby"><code><span class="token comment">#第一行必须指定基于的基础镜像</span>
<span class="token constant">From</span> ubutu
<span class="token comment">#维护者信息</span>
<span class="token constant">MAINTAINER</span> docker_user  docker_user<span class="token variable">@mail</span><span class="token punctuation">.</span>com
<span class="token comment">#镜像的操作指令</span>
apt<span class="token operator">/</span>sourcelist<span class="token punctuation">.</span>list
<span class="token constant">RUN</span> apt<span class="token operator">-</span>get update <span class="token operator">&amp;&amp;</span> apt<span class="token operator">-</span>get install <span class="token operator">-</span>y ngnix 
<span class="token constant">RUN</span> echo <span class="token string">&quot;\ndaemon off;&quot;</span><span class="token operator">&gt;</span><span class="token operator">&gt;</span><span class="token operator">/</span>etc<span class="token operator">/</span>ngnix<span class="token operator">/</span>nignix<span class="token punctuation">.</span>conf
<span class="token comment">#容器启动时执行指令</span>
<span class="token constant">CMD</span> <span class="token operator">/</span>usr<span class="token operator">/</span>sbin<span class="token operator">/</span>ngnix
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>6.2 Dockerfile 指令</p> <ul><li>1、From 指令<br>
From 或者 From :<br>
DockerFile 第一条必须为 From 指令。如果同一个 DockerFile 创建多个镜像时，可使用多个 From 指令（每个镜像一次）</li> <li>2、MAINTAINER<br>
格式为 maintainer ，指定维护者的信息</li> <li>3、RUN<br>
格式为 Run 或者 Run [“executable” ,”Param1”, “param2”]<br>
前者在 shell 终端上运行，即/bin/sh -C，后者使用 exec 运行。例如：RUN [“/bin/bash”, “-c”,”echo hello”]<br>
每条 run 指令在当前基础镜像执行，并且提交新镜像。当命令比较长时，可以使用“/”换行。</li></ul> <blockquote><blockquote><p>exec 命令用于调用并执行指令的命令。exec 命令通常用在 shell 脚本程序中，可以调用其他的命令。如果在当前终端中使用命令，则当指定的命令执行完毕后会立即退出终端。<br>
-c：在空环境中执行指定的命令。<br>
例如：exec -c echo Linux C++</p></blockquote></blockquote> <ul><li><p>4、CMD 指令<br>
支持三种格式：<br>
CMD [“executable” ,”Param1”, “param2”]使用 exec 执行，推荐<br>
CMD command param1 param2，在/bin/sh 上执行<br>
CMD [“Param1”, “param2”] 提供给 ENTRYPOINT 做默认参数。<br> <strong>每个容器只能执行一条 CMD 命令，多个 CMD 命令时，只最后一条被执行。</strong></p></li> <li><p>5、EXPOSE<br>
格式为 EXPOSE [……] 。<br>
告诉 Docker 服务端容器暴露的端口号，供互联系统使用。在启动 Docker 时，可以通过-P,主机会自动分配一个端口号转发到指定的端口。使用-P，则可以具体指定哪个本地端口映射过来<br>
例如：<br>
EXPOSE 22 80 8443</p></li> <li><p>6、ENV<br>
格式为 ENV 。 指定一个环境变量，会被后续 RUN 指令使用，并在容器运行时保持。<br>
例如<br>
ENV PG_MAJOR 9.3<br>
ENV PG_VERSION 9.3.4<br>
RUN curl -SL <a href="http://example.com/postgres-%24PG_VERSION.tar.xz" target="_blank" rel="noopener noreferrer">http://example.com/postgres-$PG_VERSION.tar.xz<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> | tar -xJC /usr/src/postgress &amp;&amp; ……<br>
ENV PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH</p></li> <li><p>7、ADD<br>
ADD 命令有两个参数，源和目标。它的基本作用是从源系统的文件系统上复制文件到目标容器的文件系统。如果源是一个 URL，那该 URL 的内容将被下载并复制到容器中。<br>
ADD [source directory or URL] [destination directory]<br>
ADD /my_app_folder /my_app_folder</p></li> <li><p>8、ENTRYPOINT<br>
两种格式：<br>
ENTRYPOINT [“executable”, “param1”, “param2”]<br>
ENTRYPOINT command param1 param2 （shell 中执行）。<br>
配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖。<br>
每个 Dockerfile 中只能有一个 ENTRYPOINT ，当指定多个时，只有最后一个起效。</p></li> <li><p>9、VOLUME<br>
格式为 VOLUME [“/data”] 。<br>
创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。</p></li></ul> <p>11、USER<br>
格式为 USER daemon 。<br>
指定运行容器时的用户名或 UID，后续的 RUN 也会使用指定用户。<br>
当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户，例如： RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres 。<strong>要临时获取管理员权限可以使用 gosu ，而不推荐 sudo 。</strong></p> <ul><li><p>11、WORKDIR<br>
格式为 WORKDIR /path/to/workdir 。<br>
为后续的 RUN 、 CMD 、 ENTRYPOINT 指令配置工作目录。<br>
可以使用多个 WORKDIR 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。例如<br>
WORKDIR /a<br>
WORKDIR b<br>
WORKDIR c<br>
RUN pwd<br>
则最终路径为 /a/b/c 。</p></li> <li><p>12、ONBUILD<br>
格式为 ONBUILD [INSTRUCTION] 。<br>
配置当所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令。<br>
例如，Dockerfile 使用如下的内容创建了镜像 image-A 。</p></li></ul> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span>…<span class="token punctuation">]</span> 
ONBUILD ADD <span class="token builtin class-name">.</span> /app/src 
ONBUILD RUN /usr/local/bin/python-build –dir /app/src 
<span class="token punctuation">[</span>…<span class="token punctuation">]</span> 
<span class="token comment">#如果基于A创建新的镜像时，新的Dockerfile中使用 FROM image-A</span>
 指定基础镜像时，会自动执行 ONBUILD 指令内容，
等价于在后面添加了两条指令。
FROM image-A
<span class="token comment">#Automatically run the following</span>
ADD <span class="token builtin class-name">.</span> /app/src
RUN /usr/local/bin/python-build --dir /app/src
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>使用 ONBUILD 指令的镜像，推荐在标签中注明，例如 ruby:1.9-onbuild 。</p> <ul><li>13 CMD 和 ENTRYPOINT 差异对比<br>
两个共同点：<br>
都可以指定 shell 或 exec 函数调用的方式执行命令；<br>
当存在多个 CMD 指令或 ENTRYPOINT 指令时，只有最后一个生效；<br>
差异：<br>
差异 1：CMD 指令指定的容器启动时命令可以被 docker run 指定的命令覆盖，而 ENTRYPOINT 指令指定的命令不能被覆盖，而是将 docker run 指定的参数当做 ENTRYPOINT 指定命令的参数。<br>
差异 2：CMD 指令可以为 ENTRYPOINT 指令设置默认参数，而且可以被 docker run 指定的参数覆盖；</li></ul> <blockquote><p>ENTRYPOINT 　<br>
An ENTRYPOINT allows you to configure a container that will run as an executable.它可以让你的容器功能表现得像一个可执行程序一样。</p> <blockquote><ul><li>例子一：<br>
使用下面的 ENTRYPOINT 构造镜像:<br>
ENTRYPOINT [&quot;/bin/echo&quot;]<br>
那么 docker build 出来的镜像以后的容器功能就像一个/bin/echo 程序：<br>
比如我 build 出来的镜像名称叫 imageecho，那么我可以这样用它：<br>
docker run -it imageecho “this is a test”<br>
这里就会输出”this is a test”这串字符，而这个 imageecho 镜像对应的容器表现出来的功能就像一个 echo 程序一样。 你添加的参数“this is a test”会添加到 ENTRYPOINT 后面，就成了这样　/bin/echo “this is a test” 。现在你应该明白进入点的意思了吧。</li> <li>例子二：<br>
ENTRYPOINT [&quot;/bin/cat&quot;]<br>
构造出来的镜像你可以这样运行(假设名为 st)：<br>
docker run -it st /etc/fstab<br>
这样相当： /bin/cat /etc/fstab 这个命令的作用。运行之后就输出/etc/fstab 里的内容。</li></ul></blockquote></blockquote> <p>6.3 镜像构建实战</p> <h3 id="docker-实战-编写-dockerfile"><a href="#docker-实战-编写-dockerfile" class="header-anchor">#</a> <a href="https://www.baidu.com/link?url=Txd6HF2sXm6ny96Fjxt-N3s5dttG95iZVSuRWtIrXvX89AX_aPaS3cRwHcBTD-JmkqeUeDlJSpewjssg6y-vZ9vK1JcdTFmhBF8rf6uXkC_&amp;wd=&amp;eqid=ba06d5a70003473c000000025b1f9ae9" target="_blank" rel="noopener noreferrer"><em>Docker_实战-编写_Dockerfile</em><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3> <div class="language-python line-numbers-mode"><pre class="language-python"><code><span class="token punctuation">[</span>root@docker docker_demo<span class="token punctuation">]</span><span class="token comment"># cat Dockerfile </span>
<span class="token comment"># base image</span>
FROM centos

<span class="token comment"># MAINTAINER</span>
MAINTAINER json_hc@<span class="token number">163.</span>com

<span class="token comment"># put nginx-1.12.2.tar.gz into /usr/local/src and unpack nginx</span>
ADD nginx<span class="token operator">-</span><span class="token number">1.12</span><span class="token number">.2</span><span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>src

<span class="token comment"># running required command</span>
RUN yum install <span class="token operator">-</span>y gcc gcc<span class="token operator">-</span>c<span class="token operator">+</span><span class="token operator">+</span> glibc make autoconf openssl openssl<span class="token operator">-</span>devel 
RUN yum install <span class="token operator">-</span>y libxslt<span class="token operator">-</span>devel <span class="token operator">-</span>y gd gd<span class="token operator">-</span>devel GeoIP \
 GeoIP<span class="token operator">-</span>devel pcre pcre<span class="token operator">-</span>devel
RUN useradd <span class="token operator">-</span>M <span class="token operator">-</span>s <span class="token operator">/</span>sbin<span class="token operator">/</span>nologin nginx

<span class="token comment"># mount a dir to container</span>
ONBUILD VOLUME <span class="token punctuation">[</span><span class="token string">&quot;/data&quot;</span><span class="token punctuation">]</span>

<span class="token comment"># change dir to /usr/local/src/nginx-1.12.2</span>
WORKDIR <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>src<span class="token operator">/</span>nginx<span class="token operator">-</span><span class="token number">1.12</span><span class="token number">.2</span>

<span class="token comment"># execute command to compile nginx</span>
RUN <span class="token punctuation">.</span><span class="token operator">/</span>configure <span class="token operator">-</span><span class="token operator">-</span>user<span class="token operator">=</span>nginx <span class="token operator">-</span><span class="token operator">-</span>group<span class="token operator">=</span>nginx <span class="token operator">-</span><span class="token operator">-</span>prefix<span class="token operator">=</span><span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>nginx \
<span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">with</span><span class="token operator">-</span><span class="token builtin">file</span><span class="token operator">-</span>aio  <span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">with</span><span class="token operator">-</span>http_ssl_module  <span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">with</span><span class="token operator">-</span>http_realip_module    \
<span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">with</span><span class="token operator">-</span>http_addition_module    <span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">with</span><span class="token operator">-</span>http_xslt_module  \
 <span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">with</span><span class="token operator">-</span>http_image_filter_module    <span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">with</span><span class="token operator">-</span>http_geoip_module  \
<span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">with</span><span class="token operator">-</span>http_sub_module  <span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">with</span><span class="token operator">-</span>http_dav_module \
<span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">with</span><span class="token operator">-</span>http_flv_module    <span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">with</span><span class="token operator">-</span>http_mp4_module \
<span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">with</span><span class="token operator">-</span>http_gunzip_module  <span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">with</span><span class="token operator">-</span>http_gzip_static_module  \
<span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">with</span><span class="token operator">-</span>http_auth_request_module  <span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">with</span><span class="token operator">-</span>http_random_index_module  \
 <span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">with</span><span class="token operator">-</span>http_secure_link_module   <span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">with</span><span class="token operator">-</span>http_degradation_module  \
 <span class="token operator">-</span><span class="token operator">-</span><span class="token keyword">with</span><span class="token operator">-</span>http_stub_status_module <span class="token operator">&amp;</span><span class="token operator">&amp;</span> make <span class="token operator">&amp;</span><span class="token operator">&amp;</span> make install

<span class="token comment"># setup PATH</span>
ENV PATH <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>nginx<span class="token operator">/</span>sbin<span class="token punctuation">:</span>$PATH

<span class="token comment"># EXPOSE</span>
EXPOSE <span class="token number">80</span>

<span class="token comment"># the command of entrypoint</span>
ENTRYPOINT <span class="token punctuation">[</span><span class="token string">&quot;nginx&quot;</span><span class="token punctuation">]</span>

CMD <span class="token punctuation">[</span><span class="token string">&quot;-g&quot;</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br></div></div><p>第 7 章 Docker 仓库<br>
7.1 官方仓库 Docker Hub<br>
7.2 国内镜像仓库<br>
7.3 私有仓库<br>
7.4 Registry 原理<br>
7.5 本章小结<br>
第 8 章 Docker 容器<br>
8.1 容器基本操作<br>
8.2 进入容器内部<br>
8.3 导出和导入容器<br>
8.4 容器结构<br>
8.5 本章小结<br>
第 9 章 数据卷<br>
9.1 数据卷是什么<br>
9.2 为容器挂载数据卷<br>
9.3 备份、恢复、迁移数据卷<br>
9.4 容器数据卷扩展<br>
9.5 本章小结<br>
第 10 章 网络管理<br>
10.1 Docker 网络基础<br>
10.2 Docker 网络模式<br>
10.3 Docker 网络配置<br>
10.4 本章小结<br>
第 3 篇 Docker 进阶实战<br>
第 11 章 操作系统<br>
11.1 Alpine 发行版<br>
11.2 Busybox 发行版<br>
11.3 Debian/Ubuntu 发行版<br>
11.4 CentOS/Fedora 发行版<br>
11.5 CoreOS 发行版<br>
11.6 RancherOS 发行版<br>
11.7 本章小结<br>
第 12 章 编排工具 Compose<br>
12.1 安装 Docker Compose<br>
12.2 Compose 命令基础<br>
12.3 Compose 配置文件<br>
12.4 Compose 实战<br>
12.5 本章小结<br>
第 13 章 Web 服务器与应用<br>
13.1 Apache 服务器<br>
13.2 Nginx 服务器<br>
13.3 Tomcat 服务器<br>
13.4 其他 Web 服务器<br>
13.5 本章小结<br>
第 14 章 数据库<br>
14.1 MySQL 数据库<br>
14.2 PostgreSQL 数据库<br>
14.3 Redis 数据库<br>
14.4 MongoDB 数据库<br>
14.5 其他<br>
14.6 本章小结<br>
第 15 章 编程语言<br>
15.1 C/C++语言<br>
15.2 Golang 语言<br>
15.3 Java 语言<br>
15.4 JavaScript（Node.js）语言<br>
15.5 PHP 语言<br>
15.6 Python 语言<br>
15.7 Swift 语言<br>
15.8 本章小结<br>
第 16 章 Docker API 介绍<br>
16.1 认识 Docker API<br>
16.2 Docker Remote API 介绍<br>
16.3 其他 API<br>
16.4 本章小结<br>
第 17 章 私有仓库<br>
17.1 Docker Registry 介绍<br>
17.2 认证与前端<br>
17.3 企业级私有仓库 Harbor<br>
17.4 私有仓库前端授权工具 Portus<br>
17.5 本章小结<br>
第 18 章 集群网络<br>
第 19 章 Docker 安全</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新时间:</span> <span class="time">11/1/2019, 3:16:13 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/skills/浏览器缓存.html" class="prev">浏览器缓存机制</a></span> <!----></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/blog/assets/js/app.679a839d.js" defer></script><script src="/blog/assets/js/2.a9010d75.js" defer></script><script src="/blog/assets/js/13.268651e9.js" defer></script>
  </body>
</html>
